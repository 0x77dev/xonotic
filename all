#!/bin/sh
# vim: filetype=zsh

set -e

d00=`pwd`
while ! [ -f ./all ]; do
	if [ x"`pwd`" = x"/" ]; then
		echo "Cannot find myself."
		echo "Please run this script with the working directory inside a Xonotic checkout."
		exit 1
	fi
	cd ..
done
d0=`pwd`
SELF="$d0/all"

# If we are on WINDOWS:
case "$0" in
	all|*/all)
		case "`uname`" in
			MINGW*|Win*)
				# Windows hates users. So this script has to copy itself elsewhere first...
				tname=
				cp "$SELF" ../all.xonotic.sh
				export WE_HATE_OUR_USERS=1
				exec ../all.xonotic.sh "$@"
				;;
		esac
		;;
esac

msg()
{
	echo "[1m$*[m"
}

checksum()
{
	if [ -x /usr/bin/md5sum ]; then
		/usr/bin/md5sum "$@"
	elif [ -x /bin/md5sum ]; then
		/bin/md5sum "$@"
	elif [ -x /usr/bin/cksum ]; then
		/usr/bin/cksum "$@"
	else
		echo "NOCHECKSUM"
	fi
}

self=`checksum "$SELF"`
checkself()
{
	self_new=`checksum "$SELF"`
	if [ x"$self" != x"$self_new" ]; then
		msg "./all has changed."
		if [ -z "$XONOTIC_FORBID_RERUN_ALL" ]; then
			msg "Rerunning the requested operation to make sure."
			export XONOTIC_FORBID_RERUN_ALL=1
			exec "$SELF" "$@"
		else
			msg "Please try $SELF update, and then retry your requested operation."
			exit 1
		fi
	fi
	return 0
}

verbose()
{
	msg "+ $*"
	"$@"
}

visible_repo_name()
{
	case "$1" in
		.)
			echo "the root directory"
			;;
		*)
			echo "\"$1\""
			;;
	esac
}

check_mergeconflict()
{
	if git ls-files -u | grep ' 1	'; then
		echo
		echo "MERGE CONFLICT."
		echo "change into the \"$1\" project directory, and then:"
		echo "- edit the files mentioned above with your favorite editor,"
		echo "  and fix the conflicts (marked with <<<<<<< blocks)"
		echo "- for binary files, you can select the files using"
		echo "  git checkout --ours or git checkout --theirs"
		echo "- when done with a file, 'git add' the file"
		echo "- when done, 'git commit'"
		echo
		exit 1
	fi
}

yesno()
{
	yesno=
	while [ x"$yesno" != x"y" -a x"$yesno" != x"n" ]; do
		eval "$2"
		echo "$1"
		IFS= read -r yesno
	done
	[ x"$yesno" = x"y" ]
}

enter()
{
	$2 cd "$1"
	check_mergeconflict "$1"
}

repos_urls="
.                             |                                                   | master      |
data/xonotic-data.pk3dir      |                                                   | master      |
data/xonotic-maps.pk3dir      |                                                   | master      |
data/xonotic-music.pk3dir     |                                                   | master      |
data/xonotic-nexcompat.pk3dir |                                                   | master      |
mediasource                   |                                                   | master      |
darkplaces                    |                                                   | div0-stable | svn
fteqcc                        | git://github.com/Blub/qclib.git                   | master      |
div0-gittools                 | git://git.icculus.org/divverent/div0-gittools.git | master      |
netradiant                    |                                                   | master      |
"
# todo: in darkplaces, change repobranch to div0-stable

repos=`echo "$repos_urls" | grep . | cut -d '|' -f 1 | tr -d ' '`

base=`git config remote.origin.url`
case "$base" in
	*/xonotic.git)
		base=${base%xonotic.git}
		;;
	*)
		echo "The main repo is not xonotic.git, what have you done?"
		exit 1
		;;
esac

repourl()
{
	t=`echo "$repos_urls" | grep "^$1 " | cut -d '|' -f 2 | tr -d ' '`
	if [ -n "$t" ]; then
		case "$t" in
			*://*)
				echo "$t"
				;;
			*)
				echo "$base$t"
				;;
		esac
	else
		if [ x"$1" = x"." ]; then
			echo "$base""xonotic.git"
		else
			echo "$base${1##*/}.git"
		fi
	fi
}

repobranch()
{
	t=`echo "$repos_urls" | grep "^$1 " | cut -d '|' -f 3 | tr -d ' '`
	if [ -n "$t" ]; then
		echo "$t"
	else
		echo "master"
	fi
}

repoflags()
{
	echo "$repos_urls" | grep "^$1 " | cut -d '|' -f 4 | tr -d ' '
	echo "$t"
}

repos=`for d in $repos; do
	p="${d%dir}"
	if [ x"$p" = x"$d" ] || [ -d "$d" ] || ! [ -f "$p" ]; then
		echo "$d"
	fi
done`

if [ "$#" = 0 ]; then
	set -- help
fi
cmd=$1
shift

case "$cmd" in
	update|pull)
		allow_pull=true
		if [ x"$1" = x"-N" ]; then
			allow_pull=false
		fi
		for d in $repos; do
			url=`repourl "$d"`
			branch=`repobranch "$d"`
			if [ -d "$d0/$d" ]; then
				if $allow_pull; then
					enter "$d0/$d" verbose
					verbose git config remote.origin.url "$url"
					verbose git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
						# TODO remove this line later

					verbose git config core.autocrlf false
					verbose git config core.safecrlf false # we don't NEED that...

					r=`git symbolic-ref HEAD`
					r=${r#refs/heads/}
					if git config branch.$r.remote >/dev/null 2>&1; then
						if ! verbose git pull; then
							check_mergeconflict "$d"
							echo "Pulling failed. Press ENTER to continue, or Ctrl-C to abort."
							read -r DUMMY
						fi
					fi

					cd "$d00"
					checkself "$cmd" "$@"
					cd "$d0/$d"
					verbose git remote prune origin
					cd "$d0"
				fi
			else
				verbose git clone "$url" "$d0/$d"
				enter "$d0/$d" verbose
				verbose git checkout "$branch"
				cd "$d0"
			fi
		done
		;;
	checkout|switch)
		remote=$1
		branch=$2
		if [ -z "$branch" ]; then
			branch=$remote
			remote=origin
		fi
		exists=false
		for d in $repos; do
			enter "$d0/$d" verbose
			if git rev-parse "refs/heads/$branch" >/dev/null 2>&1; then
				exists=true
				verbose git checkout "$branch"
			elif git rev-parse "refs/remotes/$remote/$branch" >/dev/null 2>&1; then
				exists=true
				verbose git checkout --track -b "$branch" "$remote/$branch"
			else
				verbose git checkout "`repobranch "$d"`"
			fi
			cd "$d00"
			checkself "$cmd" "$@"
			cd "$d0"
		done
		if ! $exists; then
			echo "The requested branch was not found in any repository."
		fi
		exec "$SELF" branch
		;;
	branch)
		remote=$1
		branch=$2
		srcbranch=$3
		if [ -z "$branch" ]; then
			branch=$remote
			remote=origin
		fi
		if [ -z "$branch" ]; then
			for d in $repos; do
				enter "$d0/$d"
				r=`git symbolic-ref HEAD`
				r=${r#refs/heads/}
				echo "$d is at $r"
				cd "$d0"
			done
		else
			for d in $repos; do
				dv=`visible_repo_name "$d"`
				enter "$d0/$d" verbose
				if git rev-parse "refs/heads/$branch" >/dev/null 2>&1; then
					echo "Already having this branch in $dv."
				else
					if yesno "Branch in $dv?"; then
						if [ -n "$srcbranch" ]; then
							b=$srcbranch
						else
							b="`repobranch "$d"`"
						fi
						# TODO do this without pushing
						verbose git push "$remote" "$b":"$branch"
						verbose git checkout --track -b "$branch" "$remote/$branch"
					fi
				fi
				cd "$d0"
			done
			"$SELF" branch
		fi
		;;
	branches)
		for d in $repos; do
			enter "$d0/$d"
			echo "In $d:"
			git branch -a -v -v | cut -c 3- | while read -r BRANCH REV UPSTREAM TEXT; do
				case "$UPSTREAM" in
					\[*)
						UPSTREAM=${UPSTREAM#\[}
						UPSTREAM=${UPSTREAM%\]}
						UPSTREAM=${UPSTREAM%:*}
						;;
					*)
						TEXT="$UPSTREAM $TEXT"
						UPSTREAM=
						;;
				esac
				if [ x"$REV" = x"->" ]; then
					continue
				fi
				BRANCH=${BRANCH#remotes/}
				echo -n "  $BRANCH"
				if [ -n "$UPSTREAM" ]; then
					echo -n " (tracking $UPSTREAM)"
				fi
				#echo " $TEXT"
				echo
			done
		done
		;;
	branches_short)
		for d in $repos; do
			cd "$d0/$d" # am in a pipe, shouldn't use enter
			git branch -a -v -v | cut -c 3- | sed "s,^,$d ,"
			cd "$d0"
		done | {
			branches_list=
			# branches_repos_*=
			while read -r d BRANCH REV UPSTREAM TEXT; do
				case "$UPSTREAM" in
					\[*)
						UPSTREAM=${UPSTREAM#\[}
						UPSTREAM=${UPSTREAM%\]}
						UPSTREAM=${UPSTREAM%:*}
						;;
					*)
						TEXT="$UPSTREAM $TEXT"
						UPSTREAM=
						;;
				esac
				if [ x"$REV" = x"->" ]; then
					continue
				fi
				BRANCH=${BRANCH#remotes/}
				ID=`echo "$BRANCH" | tr -c "A-Za-z0-9." "_"`
				branches_list="$branches_list $BRANCH" # TEH SORT MAKEZ IT UNIEQ
				eval "r=\$branches_repos_$ID"
				r="$r $d:$UPSTREAM"
				eval "branches_repos_$ID=\$r"
			done
			echo -n "$branches_list" | xargs -n 1 echo | sort -u | while IFS= read -r BRANCH; do
				ID=`echo "$BRANCH" | tr -c "A-Za-z0-9." "_"`
				eval "r=\$branches_repos_$ID"
				echo "$BRANCH: $r"
			done
		}
		;;
	merge)
		for d in $repos; do
			dv=`visible_repo_name "$d"`
			enter "$d0/$d" verbose
			r=`git symbolic-ref HEAD`
			r=${r#refs/heads/}
			if git log HEAD..origin/"`repobranch "$d"`" | grep .; then
				# we have uncommitted changes
				if yesno "Could merge from \"`repobranch "$d"`\" into \"$r\" in $dv. Do it?"; then
					if ! verbose git merge origin/"`repobranch "$d"`"; then
						check_mergeconflict "$d"
						exit 1 # this should ALWAYS be fatal
					fi
				fi
			fi
			cd "$d0"
		done
		;;
	push|commit)
		submit=$1
		for d in $repos; do
			dv=`visible_repo_name "$d"`
			enter "$d0/$d" verbose
			r=`git symbolic-ref HEAD`
			r=${r#refs/heads/}
			if git diff HEAD | grep .; then
				# we have uncommitted changes
				if yesno "Uncommitted changes in \"$r\" in $dv. Commit?"; then
					verbose git commit -a
				fi
			fi
			rem=`git config "branch.$r.remote" || echo origin`
			if { git log "$rem/$r".."$r" || git log origin/"`repobranch "$d"`".."$r"; } | grep .; then
				if yesno "Push \"$r\" in $dv?"; then
					verbose git push "$rem" HEAD
				fi
			fi
			if [ x"$submit" = x"-s" ]; then
				case "$r" in
					*/*)
						verbose git push "$rem" HEAD:"${r%%/*}/finished/${r#*/}"
						;;
				esac
			fi
			cd "$d0"
		done
		;;
	compile)
		if [ -n "$WE_HATE_OUR_USERS" ]; then
			TARGETS="sv-debug cl-debug"
		else
			TARGETS="sv-debug cl-debug sdl-debug"
		fi
		case "$1" in
			-c)
				clean=true
				shift
				;;
			*)
				clean=false
				;;
		esac
		case "$1" in
			sdl)
				TARGETS="sdl-debug"
				shift
				;;
			glx|agl|wgl)
				TARGETS="cl-debug"
				shift
				;;
			dedicated)
				TARGETS="sv-debug"
				shift
				;;
		esac
		if [ -z "$MAKEFLAGS" ]; then
			if [ -f /proc/cpuinfo ]; then
				ncpus=$((`grep -c '^processor	:' /proc/cpuinfo`+0))
				if [ $ncpus -gt 1 ]; then
					MAKEFLAGS=-j$ncpus
				fi
			fi
			case "`uname`" in
				Linux|*BSD)
					MAKEFLAGS="$MAKEFLAGS DP_LINK_TO_LIBJPEG=1"
					;;
			esac
			if [ -n "$WE_HATE_OUR_USERS" ]; then
				MAKEFLAGS="$MAKEFLAGS DP_MAKE_TARGET=mingw"
			fi
		fi
		enter "$d0/fteqcc" verbose
		if $clean; then
			verbose make $MAKEFLAGS clean
		fi
		verbose make $MAKEFLAGS
		enter "$d0/data/xonotic-data.pk3dir" verbose
		if $clean; then
			verbose make $MAKEFLAGS clean
		fi
		verbose make FTEQCC="$d0/fteqcc/fteqcc.bin" "$@" $MAKEFLAGS clean
		verbose make FTEQCC="$d0/fteqcc/fteqcc.bin" "$@" $MAKEFLAGS
		enter "$d0/darkplaces" verbose
		if $clean; then
			verbose make $MAKEFLAGS clean
		fi
		for T in $TARGETS; do
			verbose make $MAKEFLAGS "$@" "$T"
		done
		;;
	run)
		if [ -n "$WE_HATE_OUR_USERS" ]; then
			client=
			export PATH="$d0/misc/buildfiles/w32:$PATH"
		elif [ x"`uname`" = x"Darwin" ]; then
			export DYLD_LIBRARY_PATH="$d0/misc/buildfiles/osx/Nexuiz.app/Contents/MacOS"
			client=-sdl
		else
			client=-sdl
		fi
		case "$1" in
			sdl|glx|agl|dedicated)
				client=-$1
				shift
				;;
			wgl)
				client=
				shift
				;;
		esac
		if ! [ -x "darkplaces/darkplaces$client" ]; then
			if [ -x "darkplaces/darkplaces$client.exe" ]; then
				client=$client.exe
			else
				echo "Client darkplaces/darkplaces$client not found, aborting"
				exit 1
			fi
		fi
		set -- "darkplaces/darkplaces$client" -nexuiz -customgamename Xonotic -customgamedirname1 data -customgamedirname2 "" -customgamescreenshotname xonotic -customgameuserdirname xonotic "$@"

		# if pulseaudio is running: USE IT
		if ps -C pulseaudio >/dev/null; then
			if ldd /usr/lib/libSDL.so 2>/dev/null | grep pulse >/dev/null; then
				export SDL_AUDIODRIVER=pulse
			fi
		fi

		if [ -n "$USE_GDB" ]; then
			set -- gdb --args "$@"
		fi
		"$@"
		;;
	each|foreach)
		for d in $repos; do
			if verbose cd "$d0/$d"; then
				verbose "$@"
				cd "$d0"
			fi
		done
		;;
	save-patches)
		outfile=$1
		patchdir=`mktemp -d -t save-patches.XXXXXX`
		for d in $repos; do
			enter "$d0/$d" verbose
			git branch -v -v | cut -c 3- | {
				i=0
				while read -r BRANCH REV UPSTREAM TEXT; do
					case "$UPSTREAM" in
						\[*)
							UPSTREAM=${UPSTREAM#\[}
							UPSTREAM=${UPSTREAM%\]}
							UPSTREAM=${UPSTREAM%:*}
							TRACK=true
							;;
						*)
							UPSTREAM=origin/"`repobranch "$d"`"
							TRACK=false
							;;
					esac
					if [ x"$REV" = x"->" ]; then
						continue
					fi
					if git format-patch -o "$patchdir/$i" "$UPSTREAM".."$BRANCH"; then
						echo "$d" > "$patchdir/$i/info.txt"
						echo "$BRANCH" >> "$patchdir/$i/info.txt"
						echo "$UPSTREAM" >> "$patchdir/$i/info.txt"
						echo "$TRACK" >> "$patchdir/$i/info.txt"
						i=$(($i+1))
					else
						rm -rf "$patchdir/$i"
					fi
				done
			}
		done
		( cd "$patchdir" && tar cvzf - . ) > "$outfile"
		rm -rf "$patchdir"
		;;
	restore-patches)
		infile=$1
		patchdir=`mktemp -d -t restore-patches.XXXXXX`
		( cd "$patchdir" && tar xvzf - ) < "$infile"
		# detach the head
		for P in "$patchdir"/*/info.txt; do
			D=${P%/info.txt}
			exec 3<"$P"
			read -r d <&3
			read -r BRANCH <&3
			read -r UPSTREAM <&3
			read -r TRACK <&3
			verbose git checkout HEAD^0
			verbose git branch -D "$BRANCH"
			if [ x"$TRACK" = x"true" ]; then
				verbose git checkout --track -b "$BRANCH" "$UPSTREAM"
			else
				verbose git branch -b "$BRANCH" "$UPSTREAM"
			fi
			verbose git am "$D"
		done
		rm -rf "$patchdir"
		;;
	admin-merge)
		if [ "$#" = 1 ]; then
			set -- "${1%%/*}" "${1#*/}"
		fi
		for d in $repos; do
			enter "$d0/$d" verbose
			git rev-parse "$1/$2" || continue
			# 1. review
			{
				git log HEAD.."$1/$2"
				git diff HEAD..."$1/$2"
			} | less
			if yesno "Merge \"$1/$2\" into `git symbolic-ref HEAD` of $d?"; then
				git merge "$1/$2"
				if "$SELF" compile && yesno "Still merge \"$1/$2\" into `git symbolic-ref HEAD` of $d? Maybe you want to test first."; then
					git push origin HEAD
					git push "$1" :"$2"
				else
					git reset --hard HEAD@{1}
				fi
			fi
		done
		;;
	admin-merge-2)
		t=`mktemp`
		for d in $repos; do
			enter "$d0/$d" verbose
			for ref in `git for-each-ref --format='%(refname)' refs/remotes/origin/`; do
				case "${ref#refs/remotes/origin/}" in
					"`repobranch "$d"`")
						continue
						;;
					HEAD|master)
						continue
						;;
				esac
				echo "$ref"
				if git notes --ref "refs/notes/admin-merge" show "$ref" 2>/dev/null; then
					echo "Not merging, already had this one"
				elif yesno "Branch \"$ref\" may want to get merged. Do it?" '{ git log HEAD.."$ref"; git diff HEAD..."$ref"; } | less'; then
					git checkout master
					org=`git rev-parse HEAD`
					if ! git merge "$ref" 2>&1 | tee "$t"; then
						git reset --hard "$org"
						git notes --ref "refs/notes/admin-merge" add -m "Merge failed:
`cat "$t"`" "$ref"
					elif ! "$SELF" compile 2>&1 | tee "$t"; then
						git reset --hard "$org"
						git notes --ref "refs/notes/admin-merge" add -m "Compile failed:
`cat "$t"`" "$ref"
					elif ! yesno "Still merge \"$ref\" into `git symbolic-ref HEAD` of $d? Maybe you want to test first."; then
						git reset --hard "$org"
						git notes --ref "refs/notes/admin-merge" add "$ref"
					else
						case ",`repoflags "$d"`," in
							*,svn,*)
								git pull
								git rebase -i "$org"
								git svn dcommit --add-author-from
								;;
							*)
								git push origin HEAD
								;;
						esac
						if yesno "Delete original branch \"$ref\"?"; then
							git push origin :"${ref#refs/remotes/origin/}"
						fi
					fi
				else
					git notes --ref "refs/notes/admin-merge" add "$ref"
				fi
			done
		done
		rm -f "$t"
		;;
	*)
		echo "Usage:"
		echo "  $SELF pull"
		echo "  $SELF merge"
		echo "  $SELF push [-s]"
		echo "  $SELF branches"
		echo "  $SELF branch [<remote>] <branchname>"
		echo "  $SELF branch <remote> <branchname> <srcbranchname>"
		echo "  $SELF checkout [<remote>] <branchname>"
		echo "  $SELF compile [-c] [<client>] <options>"
		echo "  $SELF run [<client>] <options>"
		echo "  $SELF each <command>"
		;;
esac
