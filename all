#!/bin/sh
# vim: filetype=zsh

set -e

# I use this in EVERY shell script ;)
LF="
"

d00=`pwd`
while ! [ -f ./all ]; do
	if [ x"`pwd`" = x"/" ]; then
		echo "Cannot find myself."
		echo "Please run this script with the working directory inside a Xonotic checkout."
		exit 1
	fi
	cd ..
done
d0=`pwd`
SELF="$d0/all"

# If we are on WINDOWS:
case "$0" in
	all|*/all)
		case "`uname`" in
			MINGW*|Win*)
				# Windows hates users. So this script has to copy itself elsewhere first...
				cp "$SELF" ../all.xonotic.sh
				export WE_HATE_OUR_USERS=1
				exec ../all.xonotic.sh "$@"
				;;
		esac
		;;
esac

msg()
{
	echo "[1m$*[m"
}

self=`git hash-object "$SELF"`
checkself()
{
	self_new=`git hash-object "$SELF"`
	if [ x"$self" != x"$self_new" ]; then
		msg "./all has changed."
		if [ -z "$XONOTIC_FORBID_RERUN_ALL" ]; then
			msg "Rerunning the requested operation to make sure."
			export XONOTIC_FORBID_RERUN_ALL=1
			exec "$SELF" "$@"
		else
			msg "Please try $SELF update, and then retry your requested operation."
			exit 1
		fi
	fi
	return 0
}

verbose()
{
	msg "+ $*"
	"$@"
}

visible_repo_name()
{
	case "$1" in
		.)
			echo "the root directory"
			;;
		*)
			echo "\"$1\""
			;;
	esac
}

check_mergeconflict()
{
	if git ls-files -u | grep ' 1	'; then
		echo
		echo "MERGE CONFLICT."
		echo "change into the \"$1\" project directory, and then:"
		echo "- edit the files mentioned above with your favorite editor,"
		echo "  and fix the conflicts (marked with <<<<<<< blocks)"
		echo "- for binary files, you can select the files using"
		echo "  git checkout --ours or git checkout --theirs"
		echo "- when done with a file, 'git add' the file"
		echo "- when done, 'git commit'"
		echo
		exit 1
	fi
}

yesno()
{
	yesno=
	while [ x"$yesno" != x"y" -a x"$yesno" != x"n" ]; do
		eval "$2"
		echo "$1"
		IFS= read -r yesno
	done
	[ x"$yesno" = x"y" ]
}

enter()
{
	$2 cd "$1" || exit 1
	check_mergeconflict "$1"
}

repos_urls="
.                             |                                                   | master      |
data/xonotic-data.pk3dir      |                                                   | master      |
data/xonotic-maps.pk3dir      |                                                   | master      |
data/xonotic-music.pk3dir     |                                                   | master      |
data/xonotic-nexcompat.pk3dir |                                                   | master      |
mediasource                   |                                                   | master      |
darkplaces                    |                                                   | div0-stable | svn
fteqcc                        | git://github.com/Blub/qclib.git                   | master      |
div0-gittools                 | git://git.icculus.org/divverent/div0-gittools.git | master      |
netradiant                    |                                                   | master      |
"
# todo: in darkplaces, change repobranch to div0-stable

repos=`echo "$repos_urls" | grep . | cut -d '|' -f 1 | tr -d ' '`

base=`git config remote.origin.url`
case "$base" in
	*/xonotic.git)
		base=${base%xonotic.git}
		;;
	*)
		echo "The main repo is not xonotic.git, what have you done?"
		exit 1
		;;
esac

repourl()
{
	repo_t=`echo "$repos_urls" | grep "^$1 " | cut -d '|' -f 2 | tr -d ' '`
	if [ -n "$repo_t" ]; then
		case "$repo_t" in
			*://*)
				echo "$repo_t"
				;;
			*)
				echo "$base$repo_t"
				;;
		esac
	else
		if [ x"$1" = x"." ]; then
			echo "$base""xonotic.git"
		else
			echo "$base${1##*/}.git"
		fi
	fi
}

repobranch()
{
	repo_t=`echo "$repos_urls" | grep "^$1 " | cut -d '|' -f 3 | tr -d ' '`
	if [ -n "$repo_t" ]; then
		echo "$repo_t"
	else
		echo "master"
	fi
}

repoflags()
{
	echo "$repos_urls" | grep "^$1 " | cut -d '|' -f 4 | tr -d ' '
}

repos=`for d in $repos; do
	p="${d%dir}"
	if [ x"$p" = x"$d" ] || [ -d "$d" ] || ! { [ -f "$d.no" ] || [ -f "$p" ]; }; then
		echo "$d"
	fi
done`

if [ "$#" = 0 ]; then
	set -- help
fi
cmd=$1
shift

case "$cmd" in
	update|pull)
		allow_pull=true
		if [ x"$1" = x"-N" ]; then
			allow_pull=false
		fi
		for d in $repos; do
			url=`repourl "$d"`
			branch=`repobranch "$d"`
			if [ -d "$d0/$d" ]; then
				if $allow_pull; then
					enter "$d0/$d" verbose
					verbose git config remote.origin.url "$url"
					verbose git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"

					verbose git config remote.origin.autocrlf input

					r=`git symbolic-ref HEAD`
					r=${r#refs/heads/}
					if git config branch.$r.remote >/dev/null 2>&1; then
						if ! verbose git pull; then
							check_mergeconflict "$d"
							echo "Pulling failed. Press ENTER to continue, or Ctrl-C to abort."
							read -r DUMMY
						fi
					fi

					cd "$d00"
					checkself "$cmd" "$@"
					cd "$d0/$d"
					verbose git remote prune origin
					cd "$d0"
				fi
			else
				verbose git clone "$url" "$d0/$d"
				enter "$d0/$d" verbose
				if [ "$branch" != "master" ]; then
					verbose git checkout --track -b "$branch" origin/"$branch"
				fi
				cd "$d0"
			fi
		done
		;;
	update-maps)
		misc/tools/xonotic-map-compiler-autobuild download
		;;
	checkout|switch)
		remote=$1
		branch=$2
		if [ -z "$branch" ]; then
			case "$remote" in
				origin/*)
					branch=${remote#origin/}
					remote=origin
					;;
				*)
					branch=$remote
					remote=origin
					;;
			esac
		fi
		exists=false
		for d in $repos; do
			enter "$d0/$d" verbose
			b=$branch
			if [ -n "$b" ] && git rev-parse "refs/heads/$b" >/dev/null 2>&1; then
				exists=true
				verbose git checkout "$b"
			elif [ -n "$b" ] && git rev-parse "refs/remotes/$remote/$b" >/dev/null 2>&1; then
				exists=true
				verbose git checkout --track -b "$b" "$remote/$b"
			else
				b=`repobranch "$d"`
				if git rev-parse "refs/heads/$b" >/dev/null 2>&1; then
					exists=true
					verbose git checkout "$b"
				elif git rev-parse "refs/remotes/$remote/$b" >/dev/null 2>&1; then
					exists=true
					verbose git checkout --track -b "$b" "$remote/$b"
				else
					echo "WTF? Not even branch $b doesn't exist in $d"
					exit 1
				fi
			fi
			cd "$d00"
			checkself "$cmd" "$@"
			cd "$d0"
		done
		if ! $exists; then
			echo "The requested branch was not found in any repository."
		fi
		exec "$SELF" branch
		;;
	branch)
		remote=$1
		branch=$2
		srcbranch=$3
		if [ -z "$branch" ]; then
			branch=$remote
			remote=origin
		fi
		if [ -z "$branch" ]; then
			for d in $repos; do
				enter "$d0/$d"
				r=`git symbolic-ref HEAD`
				r=${r#refs/heads/}
				echo "$d is at $r"
				cd "$d0"
			done
		else
			for d in $repos; do
				dv=`visible_repo_name "$d"`
				enter "$d0/$d" verbose
				if git rev-parse "refs/heads/$branch" >/dev/null 2>&1; then
					echo "Already having this branch in $dv."
				else
					if yesno "Branch in $dv?"; then
						if [ -n "$srcbranch" ]; then
							b=$srcbranch
						else
							b=origin/"`repobranch "$d"`"
							verbose git fetch origin || true
						fi
						# TODO do this without pushing
						verbose git checkout -b "$branch" "$b"
						verbose git config "branch.$branch.remote" "$remote"
						verbose git config "branch.$branch.merge" "refs/heads/$branch"
					fi
				fi
				cd "$d0"
			done
			"$SELF" branch
		fi
		;;
	branches)
		for d in $repos; do
			cd "$d0/$d" # am in a pipe, shouldn't use enter
			git branch -a -v -v | cut -c 3- | sed "s/^(no branch)/(no_branch)/" | sed "s,^,$d ,"
			cd "$d0"
		done | {
			branches_list=
			# branches_repos_*=
			while read -r d BRANCH REV UPSTREAM TEXT; do
				if [ x"$BRANCH" = x"`repobranch "$d"`" ]; then
					continue
				fi
				case "$UPSTREAM" in
					\[*)
						UPSTREAM=${UPSTREAM#\[}
						UPSTREAM=${UPSTREAM%\]}
						UPSTREAM=${UPSTREAM%:*}
						;;
					*)
						TEXT="$UPSTREAM $TEXT"
						UPSTREAM=
						;;
				esac
				if [ x"$REV" = x"->" ]; then
					continue
				fi
				BRANCH=${BRANCH#remotes/}
				ID=`echo "$BRANCH" | tr -c "A-Za-z0-9." "_"`
				branches_list="$branches_list $BRANCH" # TEH SORT MAKEZ IT UNIEQ
				eval "r=\$branches_repos_$ID"
				case "$UPSTREAM" in
					'')
						r="$r $d"
						;;
					*)
						r="$r $d:$UPSTREAM"
						;;
				esac
				eval "branches_repos_$ID=\$r"
			done
			echo -n "$branches_list" | xargs -n 1 echo | sort -u | while IFS= read -r BRANCH; do
				ID=`echo "$BRANCH" | tr -c "A-Za-z0-9." "_"`
				eval "r=\$branches_repos_$ID"
				printf "%-60s %s\n" "$BRANCH" "$r"
				#echo "$BRANCH: $r"
			done
		}
		;;
	merge)
		for d in $repos; do
			dv=`visible_repo_name "$d"`
			enter "$d0/$d" verbose
			r=`git symbolic-ref HEAD`
			r=${r#refs/heads/}
			if git log HEAD..origin/"`repobranch "$d"`" | grep .; then
				# we have uncommitted changes
				if yesno "Could merge from \"`repobranch "$d"`\" into \"$r\" in $dv. Do it?"; then
					if ! verbose git merge origin/"`repobranch "$d"`"; then
						check_mergeconflict "$d"
						exit 1 # this should ALWAYS be fatal
					fi
				fi
			fi
			cd "$d0"
		done
		;;
	push|commit)
		submit=$1
		for d in $repos; do
			dv=`visible_repo_name "$d"`
			enter "$d0/$d" verbose
			r=`git symbolic-ref HEAD`
			r=${r#refs/heads/}
			diffdata=`git diff --color HEAD`
			if [ -n "$diffdata" ]; then
				# we have uncommitted changes
				if yesno "Uncommitted changes in \"$r\" in $dv. Commit?" 'echo "$diffdata" | less -r'; then
					verbose git commit -a
				fi
			fi
			rem=`git config "branch.$r.remote" || echo origin`
			bra=`git config "branch.$r.merge" || echo "$r"`
			upstream="$rem/${bra#refs/heads/}"
			if ! git rev-parse "$upstream" >/dev/null 2>&1; then
				upstream="origin/`repobranch "$d"`"
			fi
			logdata=`git log --color "$upstream".."$r"`
			if [ -n "$logdata" ]; then
				if yesno "Push \"$r\" in $dv?" 'echo "$logdata" | less -r'; then
					verbose git push "$rem" HEAD
				fi
			fi
			if [ x"$submit" = x"-s" ]; then
				case "$r" in
					*/*)
						verbose git push "$rem" HEAD:"${bra%%/*}/finished/${bra#*/}"
						;;
				esac
			fi
			cd "$d0"
		done
		;;
	compile)
		if [ -n "$WE_HATE_OUR_USERS" ]; then
			TARGETS="sv-debug cl-debug"
			if [ -z "$CC" ]; then
				export CC=gcc
			fi
		elif [ x"`uname`" = x"Darwin" ]; then
			case "`uname -r`" in
				?.*)
					TARGETS="sv-debug cl-debug sdl-debug"
					;;
				*)
					# AGL cannot be compiled on systems with a kernel > 10.x (Snow Leopard)
					TARGETS="sv-debug sdl-debug"
					;;
			esac
			export CC="gcc -I$PWD/misc/buildfiles/osx/Xonotic-SDL.app/Contents/Frameworks/SDL.framework/Headers -F$PWD/misc/buildfiles/osx/Xonotic-SDL.app/Contents/Frameworks"
		else
			TARGETS="sv-debug cl-debug sdl-debug"
		fi
		case "$1" in
			-c)
				cleandp=true
				cleanqcc=true
				cleanqc=true
				shift
				;;
			-n)
				cleandp=false
				cleanqcc=false
				cleanqc=false
				shift
				;;
			*)
				cleandp=false
				cleanqcc=false
				cleanqc=true # version info
				;;
		esac
		if [ $# -gt 0 ] && [ x"$1" = x"" ]; then
			# if we give the command make the arg "", it will surely fail (invalid filename),
			# so better handle it as an empty client option
			BAD_TARGETS=" "
			shift
		elif [ -n "$1" ]; then
			BAD_TARGETS=
			TARGETS_SAVE=$TARGETS
			TARGETS=
			for X in $1; do
				case "$X" in
					sdl)
						TARGETS="$TARGETS sdl-debug"
						;;
					glx|agl|wgl)
						TARGETS="$TARGETS cl-debug"
						;;
					dedicated)
						TARGETS="$TARGETS sv-debug"
						;;
					*)
						BAD_TARGETS="$BAD_TARGETS $X"
						;;
				esac
			done
			if [ -n "$TARGETS" ]; then # at least a valid client
				shift
			else # no valid client, let's assume this option is not meant to be a client then
				TARGETS=$TARGETS_SAVE
				BAD_TARGETS=
			fi
		fi
		if [ -z "$MAKEFLAGS" ]; then
			if [ -f /proc/cpuinfo ]; then
				ncpus=$((`grep -c '^processor	:' /proc/cpuinfo`+0))
				if [ $ncpus -gt 1 ]; then
					MAKEFLAGS=-j$ncpus
				fi
			fi
			case "`uname`" in
				Linux|*BSD)
					MAKEFLAGS="$MAKEFLAGS DP_LINK_TO_LIBJPEG=1"
					;;
			esac
			if [ -n "$WE_HATE_OUR_USERS" ]; then
				MAKEFLAGS="$MAKEFLAGS DP_MAKE_TARGET=mingw"
			fi
		fi

		enter "$d0/fteqcc" verbose
		if $cleanqcc; then
			verbose make $MAKEFLAGS clean
		fi
		verbose make $MAKEFLAGS

		enter "$d0/data/xonotic-data.pk3dir" verbose
		if $cleanqc; then
			verbose make FTEQCC="$d0/fteqcc/fteqcc.bin" "$@" $MAKEFLAGS clean
		fi
		verbose make FTEQCC="$d0/fteqcc/fteqcc.bin" "$@" $MAKEFLAGS

		enter "$d0/darkplaces" verbose
		if [ x"$BAD_TARGETS" = x" " ]; then
			echo "Warning: invalid empty client, default clients will be used."
		fi
		if $cleandp; then
			verbose make $MAKEFLAGS clean
		fi
		for T in $TARGETS; do
			verbose make $MAKEFLAGS "$@" "$T"
		done
		for T in $BAD_TARGETS; do
			echo "Warning: discarded invalid client $T."
		done

		verbose "$SELF" update-maps
		;;
	run)
		if [ -n "$WE_HATE_OUR_USERS" ]; then
			client=
			export PATH="$d0/misc/buildfiles/w32:$PATH"
		elif [ x"`uname`" = x"Darwin" ]; then
			export DYLD_LIBRARY_PATH="$d0/misc/buildfiles/osx/Xonotic-SDL.app/Contents/MacOS"
			export DYLD_FRAMEWORK_PATH="$d0/misc/buildfiles/osx/Xonotic-SDL.app/Contents/Frameworks"
			client=-sdl
		else
			client=-sdl
		fi
		case "$1" in
			sdl|glx|agl|dedicated)
				client=-$1
				shift
				;;
			wgl)
				client=
				shift
				;;
		esac
		if ! [ -x "darkplaces/darkplaces$client" ]; then
			if [ -x "darkplaces/darkplaces$client.exe" ]; then
				client=$client.exe
			else
				echo "Client darkplaces/darkplaces$client not found, aborting"
				exit 1
			fi
		fi
		set -- "darkplaces/darkplaces$client" -nexuiz -customgamename Xonotic -customgamedirname1 data -customgamedirname2 "" -customgamescreenshotname xonotic -customgameuserdirname xonotic -mygames "$@"

		# if pulseaudio is running: USE IT
		if [ -z "$SDL_AUDIODRIVER" ] && ! [ -n "$WE_HATE_OUR_USERS" ] && ! [ x"`uname`" = x"Darwin" ]; then
			if ps -C pulseaudio >/dev/null; then
				if ldd /usr/lib/libSDL.so 2>/dev/null | grep pulse >/dev/null; then
					export SDL_AUDIODRIVER=pulse
				fi
			fi
		fi

		if [ -n "$USE_GDB" ]; then
			set -- gdb --args "$@"
		fi
		"$@"
		;;
	each|foreach)
		keep_going=false
		if [ x"$1" = x"-k" ]; then
			keep_going=true
			shift
		fi
		for d in $repos; do
			if verbose cd "$d0/$d"; then
				if $keep_going; then
					verbose "$@" || true
				else
					verbose "$@"
				fi
				cd "$d0"
			fi
		done
		;;
	save-patches)
		outfile=$1
		patchdir=`mktemp -d -t save-patches.XXXXXX`
		for d in $repos; do
			enter "$d0/$d" verbose
			git branch -v -v | cut -c 3- | {
				i=0
				while read -r BRANCH REV UPSTREAM TEXT; do
					case "$UPSTREAM" in
						\[*)
							UPSTREAM=${UPSTREAM#\[}
							UPSTREAM=${UPSTREAM%\]}
							UPSTREAM=${UPSTREAM%:*}
							TRACK=true
							;;
						*)
							UPSTREAM=origin/"`repobranch "$d"`"
							TRACK=false
							;;
					esac
					if [ x"$REV" = x"->" ]; then
						continue
					fi
					if git format-patch -o "$patchdir/$i" "$UPSTREAM".."$BRANCH"; then
						echo "$d" > "$patchdir/$i/info.txt"
						echo "$BRANCH" >> "$patchdir/$i/info.txt"
						echo "$UPSTREAM" >> "$patchdir/$i/info.txt"
						echo "$TRACK" >> "$patchdir/$i/info.txt"
						i=$(($i+1))
					else
						rm -rf "$patchdir/$i"
					fi
				done
			}
		done
		( cd "$patchdir" && tar cvzf - . ) > "$outfile"
		rm -rf "$patchdir"
		;;
	restore-patches)
		infile=$1
		patchdir=`mktemp -d -t restore-patches.XXXXXX`
		( cd "$patchdir" && tar xvzf - ) < "$infile"
		# detach the head
		for P in "$patchdir"/*/info.txt; do
			D=${P%/info.txt}
			exec 3<"$P"
			read -r d <&3
			read -r BRANCH <&3
			read -r UPSTREAM <&3
			read -r TRACK <&3
			verbose git checkout HEAD^0
			verbose git branch -D "$BRANCH"
			if [ x"$TRACK" = x"true" ]; then
				verbose git checkout --track -b "$BRANCH" "$UPSTREAM"
			else
				verbose git branch -b "$BRANCH" "$UPSTREAM"
			fi
			verbose git am "$D"
		done
		rm -rf "$patchdir"
		;;
	admin-merge)
		branch=$1
		t=`mktemp`
		report=""
		reportecho()
		{
			report=$report"$*$LF"
			echo "$*"
		}
		reportecho4()
		{
			report=$report"    $*$LF"
			echo "    $*"
		}
		reportdo4()
		{
			o=`"$@" | sed 's/^/    /' || true`
			reportecho "$o"
		}
		for d in $repos; do
			enter "$d0/$d" verbose
			base="`repobranch "$d"`"
			reportecho "In $d:"
			for ref in `git for-each-ref --format='%(refname)' refs/remotes/origin/`; do
				case "${ref#refs/remotes/origin/}" in
					"$base")
						continue
						;;
					HEAD|master)
						continue
						;;
					*/*)
						;;
					*)
						continue
						;;
				esac
				if [ -n "$branch" ]; then
					if [ x"$branch" != x"${ref#refs/remotes/origin/}" ]; then
						continue
					fi
				fi
				case "$base" in
					master)
						realbase=$base
						;;
					*)
						l0=`git rev-list "$base".."$ref" | wc -l`
						l1=`git rev-list master.."$ref" | wc -l`
						if [ $l0 -gt $l1 ]; then
							realbase=master
						else
							realbase=$base
						fi
						;;
				esac
				reportecho "  Branch $ref:"
				note=`GIT_NOTES_REF=refs/notes/admin-merge git notes show "$ref" 2>/dev/null || true`
				logdata=`git log --color "$realbase".."$ref"`
				if [ -z "$logdata" ]; then
					reportecho4 "--> not merging, no changes vs master"
					if yesno "Branch \"$ref\" probably should get deleted. Do it?" ''; then
						git push origin :"${ref#refs/remotes/origin/}"
						reportecho4 "--> branch deleted"
					fi
				else
					diffdata=`git diff --color --find-copies-harder --ignore-space-change "$realbase"..."$ref"`
					if [ -z "$diffdata" ]; then
						reportecho4 "--> not merging, no changes vs master, branch contains redundant history"
						if yesno "Branch \"$ref\" probably should get deleted. Do it?" '{ echo "$logdata"; } | less -r'; then
							git push origin :"${ref#refs/remotes/origin/}"
							reportecho4 "--> branch deleted"
						fi
					elif [ -z "$branch" ] && [ -n "$note" ]; then
						reportdo4 echo "$note"
						reportecho4 "--> not merging, already had this one rejected before"
					elif yesno "Branch \"$ref\" may want to get merged. Do it?" '{ echo "$logdata"; echo "$diffdata"; } | less -r'; then
						git checkout "$realbase"
						org=`git rev-parse HEAD`
						if ! git merge --no-ff "$ref" 2>&1 | tee "$t" && ! { git ls-files -u | grep ' 1   ' >/dev/null; }; then
							git reset --hard "$org"
							GIT_NOTES_REF=refs/notes/admin-merge git notes edit -m "Merge failed:$LF`cat "$t"`" "$ref"
							reportdo4 cat "$t"
							reportecho4 "--> merge failed"
						elif ! "$SELF" compile -n 2>&1 | tee "$t"; then
							git reset --hard "$org"
							GIT_NOTES_REF=refs/notes/admin-merge git notes edit -m "Compile failed:$LF`cat "$t"`" "$ref"
							reportdo4 cat "$t"
							reportecho4 "--> compile failed"
						elif ! yesno "Still merge \"$ref\" into `git symbolic-ref HEAD` of $d? Maybe you want to test first."; then
							git reset --hard "$org"
							GIT_NOTES_REF=refs/notes/admin-merge git notes edit "$ref"
							note=`GIT_NOTES_REF=refs/notes/admin-merge git notes show "$ref" 2>/dev/null || true`
							if [ x"$note" = x"del" ]; then
								git push origin :"${ref#refs/remotes/origin/}"
								reportecho4 "--> test failed, branch deleted"
							elif [ -n "$note" ]; then
								reportdo4 echo "$note"
								reportecho4 "--> test failed"
							else
								reportecho4 "--> test failed, postponed"
							fi
						else
							echo "MERGING"
							case ",`repoflags "$d"`," in
								*,svn,*)
									# we do quite a mess here... luckily we know $org
									git fetch # svn needs to be current
									git rebase -i --onto origin/master "$org"
									git svn dcommit --add-author-from
									git reset --hard "$org"
									;;
								*)
									git push origin HEAD
									;;
							esac
							reportecho4 "--> MERGED"
							if yesno "Delete original branch \"$ref\"?"; then
								git push origin :"${ref#refs/remotes/origin/}"
								reportecho4 "--> branch deleted"
							fi
						fi
					else
						GIT_NOTES_REF=refs/notes/admin-merge git notes edit "$ref"
						note=`GIT_NOTES_REF=refs/notes/admin-merge git notes show "$ref" 2>/dev/null || true`
						if [ x"$note" = x"del" ]; then
							git push origin :"${ref#refs/remotes/origin/}"
							reportecho4 "--> branch deleted"
						elif [ -n "$note" ]; then
							reportdo4 echo "$note"
							reportecho4 "--> rejected"
						else
							reportecho4 "--> postponed"
						fi
					fi
				fi
				reportecho ""
			done
			reportecho ""
		done
		rm -f "$t"
		echo "$report" | ssh nexuiz@rm.endoftheinternet.org cat '>>' public_html/xonotic-merge-notes.txt
		;;

	# release building goes here
	release-mkdir)
		mkdir -p Xonotic/"$1"
		;;
	release-prepare)
#"$SELF" each git clean -fxd
		mkdir -p Xonotic
		"$SELF" release-copy Docs/
		"$SELF" release-copy misc/
		"$SELF" release-copy server/
		"$SELF" release-copy xonotic-linux-glx.sh
		"$SELF" release-copy xonotic-linux-sdl.sh
		"$SELF" release-mkdir data
		"$SELF" release-mkdir fteqcc
		;;
	release-copy)
		rsync --exclude=.git -vaSHPAX "$1" Xonotic/"$1"
		;;
	release-compile-run)
		host=$1
		buildpath=$2
		maketargets=$3
		makeflags=$4
		srcdir=$5
		targetfiles=$6
		rsync --delete -zvaSHPAX "$srcdir"/ "$host:$buildpath/"
		ssh "$host" ". ~/.profile && cd $buildpath && make clean $maketargets $makeflags"
        for f in $targetfiles; do
			rsync -zvaSHPAX "$host:$buildpath/${f%:*}" "${f##*:}"
		done
		;;
	release-compile)
		suffix=$1
		makeflags=$2
		fteqcc_maketargets=$3
		fteqcc_files=$4
		darkplaces_maketargets=$5
		darkplaces_files=$6
		"$SELF" release-compile-run "xonotic-build-$suffix" /tmp/fteqcc.build."$suffix" "$fteqcc_maketargets" "$makeflags" "fteqcc" "$fteqcc_files"
		"$SELF" release-compile-run "xonotic-build-$suffix" /tmp/Darkplaces.build."$suffix" "$darkplaces_maketargets" "$makeflags" "fteqcc" "$darkplaces_files"
		;;
	release-engine-win32)
		rsync --exclude=.git -vaSHPAX Xonotic/misc/buildfiles/w32/* Xonotic/
		"$SELF" release-compile win32 \
			'"DP_MAKE_TARGET=mingw CC="i586-mingw32msvc-gcc -Wl,--dynamicbase -Wl,--nxcompat -g -DSUPPORTDIRECTX -DUSE_WSPIAPI_H -I$HOME/dp.win32/include -L$HOME/dp.win32/lib" WINDRES="i586-mingw32msvc-windres" SDL_CONFIG="$HOME/dp.win32/bin/sdl-config"' \
			win 'fteqcc.exe:Xonotic/fteqcc/fteqcc.exe' \
			debug 'darkplaces.exe:xonotic.exe darkplaces-sdl.exe:xonotic-sdl.exe darkplaces-dedicated.exe:xonotic-dedicated.exe'
		;;
	release-engine-win64)
		rsync --exclude=.git -vaSHPAX Xonotic/misc/buildfiles/w32/* Xonotic/
		"$SELF" release-compile win32 \
			'"DP_MAKE_TARGET=mingw CC="amd64-mingw32msvc-gcc -Wl,--dynamicbase -Wl,--nxcompat -g -DSUPPORTDIRECTX -DUSE_WSPIAPI_H -I$HOME/dp.win64/include -L$HOME/dp.win64/lib" WINDRES="amd64-mingw32msvc-windres" SDL_CONFIG="$HOME/dp.win64/bin/sdl-config"' \
			win 'fteqcc.exe:Xonotic/fteqcc/fteqcc-64.exe' \
			debug 'darkplaces.exe:xonotic-64.exe darkplaces-sdl.exe:xonotic-sdl-64.exe darkplaces-dedicated.exe:xonotic-dedicated-64.exe'
		;;
	release-engine-osx)
		rsync --exclude=.git -vaSHPAX Xonotic/misc/buildfiles/osx/* Xonotic/
		"$SELF" release-compile osx \
			'CC="gcc -g -arch i386 -arch ppc -arch x86_64 -isysroot /Developer/SDKs/MacOSX10.5.sdk -mmacosx-version-min=10.5 -I$HOME/dp.osx/include -L$HOME/dp.osx/lib"' \
			all 'fteqcc.bin:Xonotic/fteqcc/fteqcc.osx' \
			sdl-debug 'darkplaces-sdl:Xonotic/Xonotic-SDL.app/Contents/MacOS/xonotic-osx-sdl-bin'
		;;
	release-engine-linux32)
		"$SELF" release-compile linux32 \
			'CC="gcc -m32 -g -Wl,--hash-style=sysv -I$HOME/dp.linux32/include -L$HOME/dp.linux32/lib" DP_MODPLUG_STATIC_LIBDIR=$HOME/dp.linux32/lib DP_LINK_TO_LIBJPEG=1' \
			all 'fteqcc.bin:Xonotic/fteqcc/fteqcc.linux32' \
			debug 'darkplaces-glx:Xonotic/xonotic-linux-linux32-glx darkplaces-sdl:Xonotic/xonotic-linux32-sdl darkplaces-dedicated:Xonotic/xonotic-linux32-dedicated'
		;;
	release-engine-linux64)
		"$SELF" release-compile linux64 \
			'CC="gcc -m64 -g -Wl,--hash-style=sysv -I$HOME/dp.linux64/include -L$HOME/dp.linux64/lib" DP_MODPLUG_STATIC_LIBDIR=$HOME/dp.linux64/lib DP_LINK_TO_LIBJPEG=1' \
			all 'fteqcc.bin:Xonotic/fteqcc/fteqcc.linux64' \
			debug 'darkplaces-glx:Xonotic/xonotic-linux-linux64-glx darkplaces-sdl:Xonotic/xonotic-linux64-sdl darkplaces-dedicated:Xonotic/xonotic-linux64-dedicated'
		;;
	release-engine)
		"$SELF" release-engine-win32 &
		"$SELF" release-engine-win64 &
		"$SELF" release-engine-osx &
		"$SELF" release-engine-linux32 &
		"$SELF" release-engine-linux64 &
		wait
		;;
	release-maps)
		"$SELF" update-maps
		for X in data/*-????????????????????????????????????????-????????????????????????????????????????.pk3; do
			if [ -f "$X" ]; then
				cd Xonotic/data/xonotic-maps.pk3dir
				unzip ../../../"$X"
				cd ../../..
			fi
		done
		;;
	release-finish)
		# version numnber and stuff like that
		;;
	release-qc)
		verbose make -C Xonotic/data/xonotic-data.pk3dir FTEQCC="$d0/Xonotic/fteqcc/fteqcc.linux32" FTEQCCFLAGS_WATERMARK=
		;;
	release-buildpk3-transform-raw)
		dir=$1
		;;
	release-buildpk3-transform-normal)
		dir=$1
		cd "$dir"
		# texture: convert to jpeg and dds
		export do_jpeg=true
		export jpeg_qual_rgb=95
		export jpeg_qual_a=99
		export do_dds=true
		export dds_flags=
		export do_ogg=false
		find textures -type f -print0 | xargs -0 "$d0"/misc/tools/cached-converter.sh
		;;
	release-buildpk3-transform-low)
		dir=$1
		cd "$dir"
		# texture: convert to jpeg and dds
		# music: reduce bitrate
		export do_jpeg=true
		export jpeg_qual_rgb=95
		export jpeg_qual_a=99
		export do_dds=false
		export do_ogg=true
		export ogg_qual=1
		find textures sound/cdtracks -type f -print0 | xargs -0 "$d0"/misc/tools/cached-converter.sh
		;;
	release-buildpk3)
		src=$1
		dst=$2
		transform=$3
		case "$dst" in
			/*)
				;;
			*/)
				dst="$PWD/$dst"
				;;
		esac
		rm -rf Xonotic/temp
		rsync --exclude=.git -vaSHPAX "$src"/ "Xonotic/temp"
		"$SELF" release-buildpk3-transform-$transform "Xonotic/temp"
		cd Xonotic/temp
		zip -9r "../../$dst" . ########### 7za a -tzip -mx=9 "../../$dst" .
		cd ../..
		rm -rf Xonotic/temp
		;;
	release-buildpk3s)
		src=$1
		shift
		while [ "$#" -gt 1 ]; do
			"$SELF" release-buildpk3 "$src" "Xonotic/${src%.pk3dir}$2.pk3" "$1"
			shift
			shift
		done
		;;
	release-pack)
		"$SELF" release-buildpk3s data/font-dejavu.pk3dir                  raw ''
		"$SELF" release-buildpk3s data/xonotic-data.pk3dir       normal '' raw '-raw' low '-low'
		"$SELF" release-buildpk3s data/xonotic-maps.pk3dir       normal '' raw '-raw' low '-low'
		"$SELF" release-buildpk3s data/xonotic-music.pk3dir      normal '' raw '-raw' low '-low'
		"$SELF" release-buildpk3s data/xonotic-nexcompat.pk3dir                       low ''
		;;
	release)
		"$SELF" release-prepare
		"$SELF" release-maps
		"$SELF" release-finish
		"$SELF" release-qc
		"$SELF" release-pack
		"$SELF" release-engine
		;;
	*)
		echo "Usage:"
		echo "  $SELF pull"
		echo "  $SELF merge"
		echo "  $SELF push [-s]"
		echo "  $SELF branches"
		echo "  $SELF branch [<remote>] <branchname>"
		echo "  $SELF branch <remote> <branchname> <srcbranchname>"
		echo "  $SELF checkout [<remote>] <branchname>"
		echo "  $SELF compile [-c|-n] [<client>] <options>"
		echo "  $SELF run [<client>] <options>"
		echo "  $SELF each <command>"
		;;
esac
